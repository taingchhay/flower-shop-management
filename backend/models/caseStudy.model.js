/**
 * User Model - Customer Account Management
 *
 * This model represents customer accounts in the flower shop system.
 * Users can register, login, browse flowers, and place orders.
 *
 * Database Table: users
 *
 * Relationships:
 * - One-to-Many with Order (User can have multiple orders)
 * - One-to-Many with ShippingAddress (User can have multiple addresses)
 * - One-to-Many with ProductReview (User can review products)
 * - One-to-Many with Wishlist (User can have wishlist items)
 *
 * Security Considerations:
 * - Passwords should be hashed before storing (use bcrypt)
 * - Email and username must be unique
 * - Input validation should be performed at controller level
 * - Support both username and full name for frontend compatibility
 *
 * @author Flower Shop Team
 * @version 2.0.0
 */

import { DataTypes } from 'sequelize';
import sequelize from '../config/sequelize.js';

/**
 * User Model Definition
 *
 * Defines the structure and constraints for user accounts.
 * All users start as regular customers with the ability to place orders.
 * Updated to support frontend registration form expectations.
 */
const User = sequelize.define('User', {
    /**
     * Primary Key - Auto-incrementing ID
     * Automatically generated by Sequelize
     */
    id: {
        type: DataTypes.INTEGER,
        primaryKey: true,
        autoIncrement: true,
        comment: 'Unique identifier for each user'
    },

    /**
     * Username - Unique identifier for login
     *
     * Constraints:
     * - Must be unique across all users
     * - Cannot be null
     * - Auto-generated from email if not provided
     * - 3-50 characters, alphanumeric + underscore
     */
    username: {
        type: DataTypes.STRING(50),
        allowNull: false,
        unique: {
            name: 'unique_username',
            msg: 'Username already exists'
        },
        validate: {
            len: {
                args: [3, 50],
                msg: 'Username must be between 3 and 50 characters'
            },
            is: {
                args: /^[a-zA-Z0-9_]+$/,
                msg: 'Username can only contain letters, numbers, and underscores'
            }
        },
        comment: 'Unique username for user identification'
    },

    /**
     * Full Name - User's display name
     *
     * This field supports the frontend registration form
     * which uses "name" instead of separate first/last names
     */
    name: {
        type: DataTypes.STRING(100),
        allowNull: true, // Allow null for backward compatibility
        validate: {
            len: {
                args: [2, 100],
                msg: 'Name must be between 2 and 100 characters'
            }
        },
        comment: 'User full name for display purposes'
    },

    /**
     * First Name - Extracted from full name or entered separately
     */
    firstName: {
        type: DataTypes.STRING(50),
        allowNull: true,
        validate: {
            len: {
                args: [1, 50],
                msg: 'First name must be between 1 and 50 characters'
            }
        },
        comment: 'User first name'
    },

    /**
     * Last Name - Extracted from full name or entered separately
     */
    lastName: {
        type: DataTypes.STRING(50),
        allowNull: true,
        validate: {
            len: {
                args: [1, 50],
                msg: 'Last name must be between 1 and 50 characters'
            }
        },
        comment: 'User last name'
    },

    /**
     * Email Address - Primary contact and login method
     *
     * Constraints:
     * - Must be unique across all users
     * - Must be valid email format
     * - Used for password reset and order notifications
     */
    email: {
        type: DataTypes.STRING(255),
        allowNull: false,
        unique: {
            name: 'unique_email',
            msg: 'Email address already registered'
        },
        validate: {
            isEmail: {
                msg: 'Must be a valid email address'
            },
            len: {
                args: [5, 255],
                msg: 'Email must be between 5 and 255 characters'
            }
        },
        comment: 'User email address for login and notifications'
    },

    /**
     * Password Hash - Encrypted password storage
     *
     * Security Notes:
     * - NEVER store plain text passwords
     * - Use bcrypt with salt rounds >= 10
     * - Validate password strength at application level
     */
    password: {
        type: DataTypes.STRING(255),
        allowNull: false,
        validate: {
            len: {
                args: [6, 255], // Allow for both plain text (validation) and hash storage
                msg: 'Password must be at least 6 characters'
            }
        },
        comment: 'Hashed password using bcrypt'
    },

    /**
     * Phone Number - Optional contact information
     */
    phone: {
        type: DataTypes.STRING(20),
        allowNull: true,
        validate: {
            is: {
                args: /^[\+]?[1-9][\d]{0,15}$/,
                msg: 'Phone number must be valid'
            }
        },
        comment: 'User phone number for contact'
    },

    /**
     * Email Verification Status
     */
    emailVerified: {
        type: DataTypes.BOOLEAN,
        allowNull: false,
        defaultValue: false,
        comment: 'Whether user email has been verified'
    },

    /**
     * Email Verification Token
     */
    emailVerificationToken: {
        type: DataTypes.STRING(255),
        allowNull: true,
        comment: 'Token for email verification'
    },

    /**
     * Password Reset Token
     */
    passwordResetToken: {
        type: DataTypes.STRING(255),
        allowNull: true,
        comment: 'Token for password reset'
    },

    /**
     * Password Reset Token Expiry
     */
    passwordResetExpires: {
        type: DataTypes.DATE,
        allowNull: true,
        comment: 'Expiry time for password reset token'
    },

    /**
     * Last Login Timestamp
     */
    lastLoginAt: {
        type: DataTypes.DATE,
        allowNull: true,
        comment: 'Timestamp of last successful login'
    },

    /**
     * Account Status - For account management
     *
     * Possible values:
     * - 'active': Normal account status
     * - 'suspended': Temporarily disabled
     * - 'deleted': Soft delete (for data retention)
     * - 'pending': Email verification pending
     */
    status: {
        type: DataTypes.ENUM('active', 'suspended', 'deleted', 'pending'),
        allowNull: false,
        defaultValue: 'pending', // Start as pending until email verified
        comment: 'Current status of the user account'
    },

    /**
     * User Role - For authorization
     */
    role: {
        type: DataTypes.ENUM('customer', 'admin'),
        allowNull: false,
        defaultValue: 'customer',
        comment: 'User role for authorization'
    },

    /**
     * User Preferences - JSON field for storing user preferences
     */
    preferences: {
        type: DataTypes.JSONB,
        allowNull: true,
        defaultValue: {},
        comment: 'User preferences and settings'
    }
}, {
    // Table configuration
    tableName: 'users',
    timestamps: true, // Enable automatic createdAt and updatedAt

    // Indexes for performance
    indexes: [
        {
            unique: true,
            fields: ['email'],
            name: 'idx_users_email'
        },
        {
            unique: true,
            fields: ['username'],
            name: 'idx_users_username'
        },
        {
            fields: ['status'],
            name: 'idx_users_status'
        },
        {
            fields: ['role'],
            name: 'idx_users_role'
        },
        {
            fields: ['emailVerified'],
            name: 'idx_users_email_verified'
        },
        {
            fields: ['createdAt'],
            name: 'idx_users_created'
        },
        {
            fields: ['lastLoginAt'],
            name: 'idx_users_last_login'
        },
        {
            fields: ['emailVerificationToken'],
            name: 'idx_users_email_token'
        },
        {
            fields: ['passwordResetToken'],
            name: 'idx_users_reset_token'
        }
    ],

    // Model-level validations
    validate: {
        /**
         * Ensure either name or firstName/lastName is provided
         */
        nameRequired() {
            if (!this.name && (!this.firstName || !this.lastName)) {
                throw new Error('Either full name or first/last name must be provided');
            }
        },

        /**
         * Validate password reset token expiry
         */
        passwordResetTokenValid() {
            if (this.passwordResetToken && !this.passwordResetExpires) {
                throw new Error('Password reset token must have expiry date');
            }
            if (this.passwordResetExpires && !this.passwordResetToken) {
                throw new Error('Password reset expiry requires token');
            }
        }
    },

    // Hooks for additional processing
    hooks: {
        /**
         * Before creating a user, process the data
         */
        beforeCreate: (user) => {
            // Normalize email and username
            user.email = user.email.toLowerCase().trim();

            // Generate username from email if not provided
            if (!user.username) {
                user.username = user.email.split('@')[0].toLowerCase();
                // Ensure username is unique by appending timestamp if needed
                user.username = user.username.substring(0, 40); // Leave room for timestamp
            } else {
                user.username = user.username.toLowerCase().trim();
            }

            // Split full name into first/last if provided
            if (user.name && !user.firstName && !user.lastName) {
                const nameParts = user.name.trim().split(' ');
                user.firstName = nameParts[0];
                user.lastName = nameParts.slice(1).join(' ') || nameParts[0];
            }

            // Combine first/last into full name if not provided
            if (!user.name && user.firstName && user.lastName) {
                user.name = `${user.firstName} ${user.lastName}`.trim();
            }

            // Trim phone number
            if (user.phone) {
                user.phone = user.phone.replace(/\s+/g, '');
            }
        },

        /**
         * Before updating a user, process the data
         */
        beforeUpdate: (user) => {
            // Normalize email if changed
            if (user.changed('email')) {
                user.email = user.email.toLowerCase().trim();
                // Reset email verification if email changed
                user.emailVerified = false;
                user.emailVerificationToken = null;
            }

            // Normalize username if changed
            if (user.changed('username')) {
                user.username = user.username.toLowerCase().trim();
            }

            // Update name fields if full name changed
            if (user.changed('name') && user.name) {
                const nameParts = user.name.trim().split(' ');
                user.firstName = nameParts[0];
                user.lastName = nameParts.slice(1).join(' ') || nameParts[0];
            }

            // Update full name if first/last name changed
            if ((user.changed('firstName') || user.changed('lastName')) && user.firstName && user.lastName) {
                user.name = `${user.firstName} ${user.lastName}`.trim();
            }

            // Trim phone number if changed
            if (user.changed('phone') && user.phone) {
                user.phone = user.phone.replace(/\s+/g, '');
            }
        },

        /**
         * After creating a user, perform additional setup
         */
        afterCreate: async (user) => {
            // Generate email verification token
            if (!user.emailVerified) {
                const crypto = await import('crypto');
                user.emailVerificationToken = crypto.randomBytes(32).toString('hex');
                await user.save();
            }
        }
    }
});

/**
 * Instance Methods
 *
 * These methods can be called on individual User instances
 */

/**
 * Get user's full profile (excluding sensitive data)
 *
 * @returns {Object} User profile without password and tokens
 */
User.prototype.getProfile = function() {
    const { password, passwordResetToken, emailVerificationToken, ...profile } = this.toJSON();
    return profile;
};

/**
 * Get user's public profile (for reviews, etc.)
 *
 * @returns {Object} Public user profile
 */
User.prototype.getPublicProfile = function() {
    return {
        id: this.id,
        name: this.name || `${this.firstName} ${this.lastName}`.trim(),
        firstName: this.firstName,
        createdAt: this.createdAt
    };
};

/**
 * Check if user account is active
 *
 * @returns {boolean} True if account is active
 */
User.prototype.isActive = function() {
    return this.status === 'active';
};

/**
 * Check if user is admin
 *
 * @returns {boolean} True if user is admin
 */
User.prototype.isAdmin = function() {
    return this.role === 'admin';
};

/**
 * Check if email is verified
 *
 * @returns {boolean} True if email is verified
 */
User.prototype.isEmailVerified = function() {
    return this.emailVerified;
};

/**
 * Generate email verification token
 *
 * @returns {Promise<string>} Verification token
 */
User.prototype.generateEmailVerificationToken = async function() {
    const crypto = await import('crypto');
    this.emailVerificationToken = crypto.randomBytes(32).toString('hex');
    await this.save();
    return this.emailVerificationToken;
};

/**
 * Generate password reset token
 *
 * @returns {Promise<string>} Reset token
 */
User.prototype.generatePasswordResetToken = async function() {
    const crypto = await import('crypto');
    this.passwordResetToken = crypto.randomBytes(32).toString('hex');
    this.passwordResetExpires = new Date(Date.now() + 3600000); // 1 hour
    await this.save();
    return this.passwordResetToken;
};

/**
 * Clear password reset token
 *
 * @returns {Promise<User>} Updated user instance
 */
User.prototype.clearPasswordResetToken = async function() {
    this.passwordResetToken = null;
    this.passwordResetExpires = null;
    return await this.save();
};

/**
 * Verify email
 *
 * @returns {Promise<User>} Updated user instance
 */
User.prototype.verifyEmail = async function() {
    this.emailVerified = true;
    this.emailVerificationToken = null;
    if (this.status === 'pending') {
        this.status = 'active';
    }
    return await this.save();
};

/**
 * Update last login timestamp
 *
 * @returns {Promise<User>} Updated user instance
 */
User.prototype.updateLastLogin = async function() {
    this.lastLoginAt = new Date();
    return await this.save();
};

/**
 * Get display name
 *
 * @returns {string} User's display name
 */
User.prototype.getDisplayName = function() {
    return this.name || `${this.firstName} ${this.lastName}`.trim() || this.username;
};

/**
 * Class Methods
 *
 * These methods can be called on the User model itself
 */

/**
 * Find user by email or username
 *
 * @param {string} identifier - Email or username
 * @returns {Promise<User|null>} User instance or null
 */
User.findByIdentifier = async function(identifier) {
    return await this.findOne({
        where: {
            [sequelize.Sequelize.Op.or]: [
                { email: identifier.toLowerCase() },
                { username: identifier.toLowerCase() }
            ]
        }
    });
};

/**
 * Find user by email verification token
 *
 * @param {string} token - Verification token
 * @returns {Promise<User|null>} User instance or null
 */
User.findByEmailVerificationToken = async function(token) {
    return await this.findOne({
        where: { emailVerificationToken: token }
    });
};

/**
 * Find user by password reset token
 *
 * @param {string} token - Reset token
 * @returns {Promise<User|null>} User instance or null
 */
User.findByPasswordResetToken = async function(token) {
    return await this.findOne({
        where: {
            passwordResetToken: token,
            passwordResetExpires: {
                [sequelize.Sequelize.Op.gt]: new Date()
            }
        }
    });
};

/**
 * Get active users count for analytics
 *
 * @returns {Promise<number>} Number of active users
 */
User.getActiveUsersCount = async function() {
    return await this.count({
        where: { status: 'active' }
    });
};

/**
 * Get user statistics
 *
 * @returns {Promise<Object>} User statistics
 */
User.getUserStats = async function() {
    const [totalUsers, activeUsers, pendingUsers, adminUsers] = await Promise.all([
        this.count(),
        this.count({ where: { status: 'active' } }),
        this.count({ where: { status: 'pending' } }),
        this.count({ where: { role: 'admin' } })
    ]);

    return {
        totalUsers,
        activeUsers,
        pendingUsers,
        adminUsers,
        customerUsers: totalUsers - adminUsers
    };
};

export default User;